<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Тестовая документация - Wiki от Вики</title>
        <link href="../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css">

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark">
            <div class="container">
                <a class="navbar-brand" href="../..">Wiki от Вики</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../.." class="nav-link">Главная</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Тестирование ПО <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../testing-part-1/" class="dropdown-item">Что такое тестирование</a>
</li>
                                    
<li>
    <a href="../testing-part-2/" class="dropdown-item">Жизненный цикл ПО/задачи</a>
</li>
                                    
<li>
    <a href="../testing-part-3/" class="dropdown-item">Классификация тестирования</a>
</li>
                                    
<li>
    <a href="./" class="dropdown-item active">Тестовая документация</a>
</li>
                                    
<li>
    <a href="../testing-part-5/" class="dropdown-item">Баг. Баг-репорт</a>
</li>
                                    
<li>
    <a href="../testing-part-6/" class="dropdown-item">Что такое веб-приложение</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Тестирование API <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../testing-api/testingapi-part-1/" class="dropdown-item">Что такое API</a>
</li>
                                    
<li>
    <a href="../../testing-api/testingapi-part-2/" class="dropdown-item">Стратегия тестирования API</a>
</li>
                                    
<li>
    <a href="../../testing-api/testingapi-part-3/" class="dropdown-item">Bookmates Документация</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Базы данных. SQL <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../db-sql/db/" class="dropdown-item">Базы данных</a>
</li>
                                    
<li>
    <a href="../../db-sql/sql/" class="dropdown-item">SQL.</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">Вопросы для собеседования <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../interview/interview_questions/" class="dropdown-item">Вопросы для собеседования</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../testing-part-3/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../testing-part-5/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="2"><a href="#-" class="nav-link">Тест-дизайн и тест-кейс</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#_1" class="nav-link">Техники Статического тестирования</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#-_1" class="nav-link">Техники тест-дизайна. Чёрный ящик.</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#-_2" class="nav-link">Техники тест-дизайна. Белый ящик.</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-level="2"><a href="#_2" class="nav-link">Техники на основе опыта.</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h2 id="-">Тест-дизайн и тест-кейс</h2>
<p>При обсуждении жизненного цикла тестирования мы говорили, что есть такие стадии, как анализ и создание тестов. Действительно перед тем как выполнять тесты, необходимо понять, какие функции и атрибуты продукта нужно проверить, при каких условиях выполнять эти проверки, какие использовать данные и каким должно быть ожидаемое поведение продукта. </p>
<p>После того как на основе требований продукта мы определились с проверками, стоит отсортировать и убрать из списка лишние, применяя тут принцип полного тестирования. Для этого необходимо использовать техники дизайна тест-кейсов.</p>
<p>Эти техники помогают определить наиболее релевантный список тестов из общего набора возможных. Каждая из этих техник подразумевает набор правил, следуя которым тестировщик определит список необходимых проверок и составит набор тест-кейсов.</p>
<p>Важный момент, который следует учесть при разработке тестов на этом этапе, — это их прослеживаемость. Что это значит? Это значит, что каждый тест идентифицирован и его можно легко связать с требованием, для которого он был разработан. Это нужно для того, чтобы при изменениях какой-то функциональности в продукте, можно было быстро и легко исправить написанные для неё тесты. Или, например, при новой версии продукта некоторые тесты заканчиваются неудачно, хотя раньше они проходили успешно. Нужно определить, для какой функциональности написаны эти тесты, для чего и нужна прослеживаемость.</p>
<p>Ещё важно на этом этапе приоритизировать список необходимых проверок, это даёт возможность уделить большее время для разработки тестов для важных функциональностей.</p>
<p>Итак, тест-дизайн — это процедура разработки тестов: тест-кейсов, чек-листов. В ходе курса мы уже  упоминали, что такое тест-кейс — это набор действий, входящих данных, а также условий, в которых должен проходить тест, и ожидаемое поведение приложения. </p>
<p>С чего начинается разработка тест-кейса? С определения условий и данных, необходимых для проведения теста. Условиями могут быть окружение, где проводится тест, версия и браузер, в котором работает приложение, база данных, к которой необходимо подключиться. Входные данные — это данные, которые приложение будет использовать для выполнения функций, например данные пользователя при авторизации в приложение. Для тест-кейса необходимо четко прописать, какой пользователь требуется для авторизации, или что для заполнения формы на расчёт суммы кредита необходимы данные клиента. Причём не стоит указывать конкретные данные, нужно их описание, роль, права, потому что тест-кейс разрабатывается не на один раз, и использовать всегда одни и те же данные неэффективно. Например, выполняя тест на заявку кредита клиенту банка, не указываем “Иванов Иван Иванович, 1990 г.р. и с заработком 30 тысяч рублей”. Указываем, например, так: для теста необходим клиент банка (который уже обращался в банк для оформления продуктов) с уровнем дохода не меньше N тысяч рублей.</p>
<p>Для тест-кейса обязателен точно определённый ожидаемый результат, иначе нельзя сказать наверняка, насколько успешно прошел тест. Ожидаемый результат — это описание тех действий и результатов, которые должен увидеть тестировщик по окончании теста (например, информация на экране, ответ от сервера пользователю, изменение даты и суммы, изменение состояния кнопки). Или можно прописывать ожидаемый результат на каждый шаг прохождения.</p>
<p>Другая часть тест-кейса — это шаги выполнения теста, то есть подробная инструкция необходимых манипуляций в приложении для достижения ожидаемого результата.</p>
<p>Когда тест-кейсы написаны, их можно и нужно приоритизировать на основе приоритета проверяемых функций. </p>
<p>Их также можно структурировать в наборы, так называемые тестовые скрипты (Test Script или Test Suite). В чем польза такого разбиения? Во-первых, оно сокращает время на прохождение тестов. Некоторые тесты имеют одинаковый набор входящих данных и могут выполняться последовательно. Например, необходимо рассчитать сумму кредита для нового клиента банка. Первый тест  заводит клиента в банковскую систему и проверяет его на надёжность. Второй тест — расчёт суммы кредита для этого клиента, т. е. тут не нужно сначала заводить клиента, тест использует клиента из предыдущей проверки. Во-вторых, некоторые наборы тестов можно проходить параллельно, что, помимо сокращения времени, даёт возможность быстро выполнить наиболее приоритетные проверки. Ну и в-третьих, тест-кейсы можно объединить в наборы часто используемых тестов, таких как smoke и sanity или регрессионное тестирование. Для каждой новой версии продукта берём конкретный набор и проводим проверку.</p>
<p>Итак, давайте подытожим основные атрибуты хорошего тест-кейса. </p>
<ul>
<li>Его идентификатор — уникальный номер, чтобы можно было определить, откуда этот тест-кейс родился.</li>
<li>Его приоритет — показатель, демонстрирующий важность тест-кейса.</li>
<li>Условия - настройки окружения и входные данные для теста.</li>
<li>Шаги тест-кейса — подробный понятный алгоритм действий для выполнения этого теста.</li>
<li>Ожидаемый результат — поведение системы, которое ожидаем после манипуляций с ней в данном тесте.</li>
</ul>
<p>Ещё важно, чтобы у тест-кейса было краткое, но понятное заглавие, по которому можно легко понять, что именно будет проверяться в данном случае.</p>
<p>Как и где оформлять тест-кейс, решает каждая команда, стандартизированного шаблона нет. Кто-то ведёт их в виде таблиц в Excel или на Confluence, кто-то в специальных инструментах, например в Zephir, TestRail.</p>
<p>Теперь поговорим о чек-листе. Это упрощённый список необходимых проверок для продукта. Можно запомнить его, ассоциируя со списком покупок. В нём вы пишите по порядку, какие части программы и  какие случаи нужно проверить и тому подобное. По сути, в нём две-три колонки: пункт проверки, его приоритет и статус или результат, который заполняется по ходу тестирования, прохождение проверки и результат прохождения. Если у вас короткий проект с несложным функционалом, вполне может хватить чек-листов, ну или у вас ограничено время на тестирование и некогда расписывать длинные конкретные тест-кейсы. А вот если все же нужна конкретика и чёткость, тогда пишем тест-кейсы.</p>
<p>К тестовой документации еще можно отнести use case или вариант использования — это высокоуровневый документ, в котором описано действие пользователя в программе. Например, пользователь должен иметь возможность регистрироваться в программе, просматривать товары, складывать их в корзину и совершать покупку. На основе таких списков пользовательских действий вы формируете список тестов.</p>
<p>Для чего важна и нужна документация на проекте? Для порядка. Если не вести такую документацию правильно и не поддерживать её в актуальном состоянии, через какое-то время вы не сможете в ней разобраться, не сможете доказать, работала ли раньше у вас функция, которая сейчас не работает, например. Во-вторых, эта документация демонстрирует команде и заказчику, как проходит тестирование, сколько функционала протестировано и сколько ещё осталось, какие функции реализованы хуже, а значит, в них наблюдается больше проблем. В-третьих, документация помогает эффективно работать, т. е. любой участник или новичок с документацией быстрее разберётся, что к чему и как тут всё работает.</p>
<p>Ещё пару слов про тестовую документацию. К ней относятся не только документы для разработки тестов, но и баг-репорт, и тест план, и стратегия, ну и требования к продукту.</p>
<h2 id="_1">Техники Статического тестирования</h2>
<p>Мы уже знакомились в курсе со статическим тестированием. Так вот, умение использовать его в работе дает хорошую возможность для улучшения качества продукта. Статическое тестирование нацелено на проверку любой документации на проекте или кода продукта, чтобы обнаружить дефекты как можно раньше. Дефектами на этом этапе могут быть:  отклонение от стандартов при составлении документации и дизайна продукта или пропущенное условие в требованиях, либо неоднозначное требование. </p>
<p>Техники статического тестирования — не замена динамическому, это эффективное дополнение к общему тестированию продукта. Оно помогает в дальнейшем сократить время на динамическое тестирование. Так как, подключаясь на ранних стадиях разработки продукта, тестировщику легче сформировать понимание того, что придётся тестировать, задать интересующие вопросы, потому как коллеги в этот момент времени находятся в контексте задачи и могут быстро и легко найти ответы. В это время также можно подумать над стратегией тестирования, набросать какой-то план для себя. Соответственно, это сократит время самого тестирования и добавит время на выполнение самих проверок, потому что уже не придётся тратить его на понимание задачи и выявление сути.
Одна из самых эффективных техник — это рецензирование (от англ. review). Оно может быть как формальным, так и неформальным. Цели такого анализа документации:</p>
<ul>
<li>обеспечить общее понимание для команды и ключевых заказчиков описанного в документации продукта или процесса;</li>
<li>найти дефекты и исправить их как можно раньше;</li>
<li>провести проверку на соблюдение стандартов и форматов при разработке продукта.</li>
</ul>
<p>Важно подойти к этому процессу серьезно, даже если это неформальный процесс. Не стоит просматривать требования как газету по диагонали.</p>
<p>Формальное рецензирование соблюдает формальный процесс, который состоит из нескольких основных стадий. Мы не будем подробно останавливаться на каждой стадии, просто обговорим их для знакомства и понимания процесса</p>
<ul>
<li>Первая стадия рецензирования — планирование (Planning). Оно начинается, когда автор документации или версии кода подаёт так называемый запрос на review, говоря тем самым: “Моя работа на этом этапе закончена, пожалуйста, проведите рецензирование, чтобы я смог исправить обнаруженные проблемы”. Координатор — человек, отвечающий за весь этот процесс — устанавливает график, стратегию и участников для данного рецензирования. В неформальном рецензировании такой этап тоже присутствует, хоть и проходит намного проще.</li>
<li>Начало рецензирования (Kick-off) — это стартовая встреча всех заинтересованных в рецензировании участников, где обсуждаются цели и стратегии процедуры.</li>
<li>Подготовка (Preparation) — участники проводят рецензирование документации и все возникшие проблемы, ошибки и опечатки фиксируют в определённом месте.</li>
<li>Встреча по окончании рецензирования (Review meeting) — встреча, где происходит обсуждение обнаруженных проблем, выставление им приоритета критичности и оценка результатов в целом.</li>
<li>Внесение изменение (Rework) — автор документа или кода вносит исправления согласно результатам рецензирования.</li>
<li>И итоговая проверка (Follow-up) — участники, ответственные за рецензирование, проверяют работу автора по исправлению, если все исправления внесены верно, работа принимается.</li>
</ul>
<p>Неформальное рецензирование проходит примерно также, исключая некоторые стадии: 1) автор подаёт запрос на review; 2) участник, проводящий review, как правило, понимает, что необходимо проверить, вносит свои комментарии для исправления проблем, если их обнаруживает, возвращает работу автору; 3) после финальных исправлений тот же ревьюер ещё раз проверяет, всё ли было исправлено и принимает работу, разрешая документу или коду двигаться по процессу дальше.</p>
<p>Один и тот же документ может проходить разные типы рецензирования. У каждого типа есть свои цели и характеристики. Выбор того или иного типа рецензирования зависит от самого проекта, количества свободных ресурсов и времени. </p>
<p>Давайте разберем основные типы рецензирования.</p>
<ul>
<li>Прохождение (Walkthrough) — участник рецензирования идёт по документу вместе с автором для того, чтобы все участники поняли его суть и дали обратную связь автору.</li>
<li>Техническое рецензирование (Technical review) — рецензирование документа по техническим аспектам, проводится техническими специалистами.</li>
<li>Инспекция (Inspection) — наиболее формальный тип рецензирования, проводится строго по процессу, соблюдая все правила.</li>
</ul>
<p>И в завершении темы несколько слов о том, как можно использовать технику рецензирования непосредственно в тестировании, когда ты ещё новичок и только учишься. При создании набора тестов или просто списка пунктов для проверок можно попросить старших коллег или наставника сделать неформальное ревью для того, чтобы не пропустить важных моментов при проверке и вообще получить фидбек о проделанной работе.</p>
<h2 id="-_1">Техники тест-дизайна. Чёрный ящик.</h2>
<p>Теперь приступим к изучению самих техник. В принципе, техники делятся на три категории: 1) основанные на требованиях к продукту, более поведенческие техники (specification-based), они же называются тестированием с помощью чёрного ящика (black box), 2) основанные на структуре продукта (structure-based) или его коде, они еще называются тестированием с помощью белого ящика (white box) и 3) основанные на пользовательском опыте. Каждая из техник имеет свои преимущества и недостатки, но каждая способна находить конкретные типы дефектов при тестировании.</p>
<p>Согласно первой технике, мы представляем программу как чёрный ящик, о содержимом которого мы ничего не знаем, т. е. не знаем, как устроены компоненты программы, какой код там используется, какие алгоритмы задействованы, как происходит взаимодействие между компонентами и самой программой с другими системами. Мы имеем только набор входящих данных и условий для выполнения и знаем результат на выходе. С помощью таких техник мы строим тесты, которые проверяют, что делает программа, но не каким образом. Например, необходимо проверить сложение двух чисел: мы имеем 2 + 2 и должны на выходе получить 4. А о том, как происходит сложение внутри программы, нам знать не нужно.</p>
<p>Black-box техники можно применять для любого уровня тестирования, полагаясь на документацию. Таких техник несколько: классы эквивалентности, анализ граничных значений, таблицы решений, модели переходов и состояний и пользовательские кейсы.</p>
<p>Итак, первая техника — разбиение на классы эквивалентности. Она практически всегда используется первой, тестировщики даже неосознанно начинают её использовать при тестировании. Однако, с ней нужно познакомиться формально, чтобы использовать по максимуму все её плюсы.  Суть такой техники в том, чтобы разбить все необходимые тестовые проверки на такие классы, которые можно воспринимать, как одно целое. Другими словами, мы подразумеваем, что для каждого пункта из класса функции приложения будут выполнены одинаково. Проводим для всего класса только один тест, и если он проходит успешно, подразумеваем, что тест будет успешен также для всех остальных пунктов. И наоборот, если тест неуспешно выполняется для одного пункта, подразумеваем, что функция не будет работать ни на одном другом пункте из этого класса. </p>
<p>Для наглядности рассмотрим простой пример: наша программа начисляет бонус в зависимости от того, какая сумма лежит на счету клиента. Если баланс клиента от 0 до 1000 рублей, начисляем 1%; если от 1000 до 5000, начисляем 3%; и если больше 5000, начисляем 5%. Какие классы эквивалентности стоит рассмотреть в этой ситуации:</p>
<ol>
<li>Баланс от 0.00  до 1000.00          -  1%</li>
<li>Баланс от 1000.01 до 5000.00        -  3%</li>
<li>Баланс от 5000.01 и выше            -  5%</li>
<li>И баланс меньше 0.00, т е до -0.01  -  процент не начисляется.</li>
</ol>
<p>Обратите внимание, что мы выделили четыре класса эквивалентности, а не три, как было заявлено в требованиях. Мы выделили 4-ый класс невалидных/недопустимых значений. Это важный пункт, потому что проверить только как должен работать продукт при хороших условиях, недостаточно. Важно ещё проверить, как поведёт себя продукт, если подать на вход ему недопустимые данные. Вот это — наглядный пример того, что только позитивного тестирования недостаточно, важно помнить про негативные проверки. Таким образом, при разработке тест-кейсов, необходимо учитывать все классы разбиения. В нашем примере минимальный набор  тест-кейсов будет состоять из четырёх штук, и входными параметрами для каждого могут быть любые значения баланса, находящиеся в пределах этого разбиения.</p>
<p>Как бы мы могли тестировать эту функцию без знания о технике разбиения на классы? Можно интуитивно подойти и тестировать, например, каждые 100 или 250 рублей. Тогда получатся следующие тесты: 0, 250, 500, 750, 1000, 1250, 1500, 1750 — восемь тест-кейсов и всё в приложении  работает хорошо. За восемь тест-кейсов можно устать и остановить тестирование с выводом о хорошем качестве. Однако, в этом случае получается, что мы проверим только два класса эквивалентности и не найдем потенциальных багов для двух других классов. В то же время мы потратим в два раза больше времени на прохождение этих восьми кейсов, чем потратили бы при использовании техники разбиения.</p>
<p>И в конце пару слов про невалидные значения. Когда мы объявляем класс невалидных значений, это не значит, что они в принципе не могут использоваться в приложении, пользователь может легко ввести такие значения в поля ввода. Приложение должно корректно обрабатывать такие ситуации, реагируя сообщением, которое даёт пользователю понять, что он ввёл недопустимые значения для этого поля.</p>
<p>Вторая техника, которую мы рассмотрим на этом уроке, — это техника анализа граничных значений. Она основана на проверке граничных значений классов разбиения. Простой пример для наглядности: есть поле ввода и кнопка. Пользователь вводит число в поле ввода, нажимает на кнопку и она становится зеленой или красной, в зависимости от того, допустимое значение ввели или нет. Допустимые значения: от 1 до 99. Так вот, используя технику разбиения мы обнаружим три класса эквивалентности:</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1      -         99</th>
<th>100</th>
</tr>
</thead>
<tbody>
<tr>
<td>Недопустимо</td>
<td>Допустимо</td>
<td>Недопустимо</td>
</tr>
</tbody>
</table>
<ol>
<li>Меньше 1 - кнопка красная</li>
<li>От 1 до 99 - кнопка зеленая</li>
<li>Больше 99 - кнопка красная.</li>
</ol>
<p>Что же будет являться граничными значениями? Для валидного класса граничные значения, очевидно, —  1 и 99. Для невалидных классов только одно граничное значение, т. к. классы не ограничены с двух сторон. Для первого это 0, для второго 100.</p>
<p>Получается, в этом примере мы должны написать три тест-кейса на классы эквивалентности и четыре тест-кейса на граничные значения. </p>
<p>Вернемся к примеру с начислением бонусов. Там граничных значений больше, так как классов больше: шесть тест-кейсов для граничных значений. А если проверять каждые 250 рублей, то только два граничных значения, 0 и 1000, будут рассмотрены, а значит велика вероятность пропустить дефекты.</p>
<p>Теперь вернёмся к неограниченным классам. В примере с бонусом у нас последний класс неограничен максимальным значением. Это не значит, что стоит проигнорировать этот момент и не тестировать его. Открытую границу немного сложнее тестировать, однако есть рабочие подходы для этого. Сначала надо погрузиться в суть этого поля, у нас это поле баланса клиента. Каким максимальным может быть баланс наших клиентов? Можно для начала  обратиться к функциональным и бизнес-требованиям продукта, поискать информацию о максимально допустимом значении баланса. Второй способ — обратиться внутрь системных компонентов, где используется это поле. Например, можно найти информацию у разработчиков о том, на сколько значений рассчитано это поле. Допустим, оно может  содержать шесть цифр и две после запятой, тогда предполагаем, что максимальная граница для этого класса 999 999.99 рублей. Если подобной информации найти нигде не удаётся, используем опыт, пытаемся найти такое большое значение, для которого программа может дать сбой. Опять же, тут не стоит тратить много усилий на проверку, например, каждой сотни или тысячи, можно, в частности, проверить порядок: 10 000, 100 000, 1000 000.</p>
<p>Используя обе эти техники вместе, можно составлять таблицу, по которой легко отслеживать ход тестирования и не забыть важные проверки.</p>
<p>Эти техники также подходят для тестирования не только числовых значений или даты и времени, но и применимы к другим значениям. Например, необходимо протестировать возможность выбора типа билета: эконом, бизнес или первый класс — вот три класса разбиения.</p>
<p>В другом случае, если при прохождении теста с каким-либо значением из класса разбиения обнаруживаем дефект, его необходимо проверить на нескольких других значений из этого класса. Если случается так, что для этих значений поведение программы отличается, возможно, было неправильно произведено деление на классы, и стоит провести более тщательный анализ для разбиения. Ну а если поведение одинаковое и отличается от ожидаемого — смело фиксируем баг.</p>
<p>Что же касается самой разработки тест-кейсов, некоторые из них, чаще всего позитивные, можно объединить в один тест, определив условия, которые необходимо проверить. Однако, если тест пройдет неуспешно, надо будет более детально разбираться в том, для какого именно условия произошел сбой. Поэтому важно научиться соблюдать баланс между покрытием слишком большого количества условий в одном тесте и слишком маленького количества. Кроме того, некоторые классы разбиения внутри можно разделить на другие классы по другому признаку. </p>
<p>Вернемся к нашему примеру  с бонусом. Допустим эти бонусы могут получать как клиенты, зарегистрированные в нашей системе, так и вновь пришедшие, или, например, клиенты с двумя и более счетами. Получается, помимо проверки начисления бонусов в пределах класса необходимо ещё выполнить проверки для разных клиентов.</p>
<p>Итак, эти техники дают возможность составить довольно приличный набор тест-кейсов, способных обнаружить дефекты. Однако как выбрать, какие тесты выполнять в первую очередь, какие позже, а какие вообще не выполнять в условиях ограниченного времени? Если цель тестирования — тщательная проверка функциональности, то стоит начинать с валидных классов эквивалентности, затем рассмотреть невалидные классы, и после — валидные и невалидные граничные значения. Если время ограничено и есть необходимость проверки наиболее распространённых пользовательских действий,  выполнять стоит тесты только из валидного класса разбиения. Если необходимо найти как можно больше дефектов за ограниченное время, стоит начать с граничных значений, допустимых и нет. А если, например, необходимо проверить, как программа обработает неверные данные для входа, выполним тесты со значением из недопустимых классов и границ.</p>
<p>В этой части осталось рассмотреть ещё три техники создания тест-кейсов на основе требований. Если первые две техники можно использовать для отдельных ситуаций или конкретного поля ввода, то  оставшиеся позволяют разработать тест-кейсы для сложных пользовательских сценариев, когда нужно учесть сразу несколько условий. Так вот, эти техники основаны больше на бизнес-логике и бизнес-процессах продукта. </p>
<p>Первая техника, которую мы начнем изучать, — таблица решений. Тестирование комбинаций довольно сложный и трудоёмкий процесс, а число комбинаций может быть огромным, что, конечно, же невозможно протестировать полностью. Работа с такой таблицей помогает найти качественный способ выбора комбинаций, которые должны быть протестированы, плюс она выявляет двусмысленность и ошибки в требованиях.</p>
<p>Первое, что нужно сделать для составления таблицы решений, — определить функцию, которая будет тестироваться в тех или иных условиях. Затем определяем входные условия и данные для работы этой функции, далее составляем таблицу всех возможных комбинаций. </p>
<p>Давайте разберемся с примером: упрощенная функция обработки пользовательских данных для кредитной заявки, где пользователь вводит ежемесячную сумму платежа или желаемый срок кредита. Приложение обрабатывает эти параметры и в дальнейшем подбирает кредитную программу.</p>
<p>Имеем два условия для входа: сумма платежа и срок кредита.</p>
<p>Прописываем их в строчки таблицы:</p>
<table>
<thead>
<tr>
<th>Условия</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Введена сумма платежа</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Введен срок кредита</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Затем заполняем столбцы таблицы, это правила — комбинации входных условий, которые необходимо проверить. Для двух условий будет четыре варианта группировки. Количество вариантов равно двум в степени числа, равному количеству группируемых условий. 2 в степени 2 равно 4.                   </p>
<table>
<thead>
<tr>
<th>Условия</th>
<th>Правило 1</th>
<th>Правило 2</th>
<th>Правило 3</th>
<th>Правило 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>Введена сумма платежа</td>
<td>И</td>
<td>И</td>
<td>Л</td>
<td>Л</td>
</tr>
<tr>
<td>Введен срок кредита</td>
<td>И</td>
<td>Л</td>
<td>И</td>
<td>Л</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Значения столбцов бинарны, имеют два значения, и их можно обозначать, как Истина (И) и Ложь (Л). Значение Истина присваивается, когда условие выполняется, т. е. мы включаем его в тест, Ложь — когда условие не берем в расчет.</p>
<p>Дальше, чтобы собрать тест-кейс до конца, необходимо в таблице определить ожидаемый результат для каждого правила. В нашем примере возможен подбор кредитной программы на основе обработки ежемесячного платежа и/или обработки срока кредита.</p>
<table>
<thead>
<tr>
<th>Условия</th>
<th>Правило 1</th>
<th>Правило 2</th>
<th>Правило 3</th>
<th>Правило 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>Введена сумма платежа</td>
<td>И</td>
<td>И</td>
<td>Л</td>
<td>Л</td>
</tr>
<tr>
<td>Введен срок кредита</td>
<td>И</td>
<td>Л</td>
<td>И</td>
<td>Л</td>
</tr>
<tr>
<td><em>Ожидаемый результат</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Происходит обработка суммы</td>
<td>Да</td>
<td>Да</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Происходит обработка срока</td>
<td>Да</td>
<td></td>
<td>Да</td>
<td></td>
</tr>
</tbody>
</table>
<p>Затем необходимо заполнить столбцы нижней части таблицы, указать, для каких комбинаций входных условий будет происходить обработка суммы, а для каких — обработка срока. Приложение может обработать сумму, если пользователь указал её значение, соответственно, если указан срок — программа обработает его. Вот таким образом мы собрали таблицу решений для простого примера с двумя условиями входа, тем самым мы покрыли позитивные сценарии для нашей функции расчета. И как мы уже говорили, важно проверить негативные ситуации, чтобы убедиться в корректности обработки таких данных, поэтому-то и осталось одно правило без обработки. Тут мы должны проверить, корректно ли приложение обработает ситуацию, когда оба поля не заполнены. Для этого в ожидаемый результат добавляем строку с ошибкой, которую должна вывести программа пользователю в этом случае.</p>
<table>
<thead>
<tr>
<th>Условия</th>
<th>Правило 1</th>
<th>Правило 2</th>
<th>Правило 3</th>
<th>Правило 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>Введена сумма платежа</td>
<td>И</td>
<td>И</td>
<td>Л</td>
<td>Л</td>
</tr>
<tr>
<td>Введен срок кредита</td>
<td>И</td>
<td>Л</td>
<td>И</td>
<td>Л</td>
</tr>
<tr>
<td><em>Ожидаемый результат</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Происходит обработка суммы</td>
<td>Да</td>
<td>Да</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Происходит обработка срока</td>
<td>Да</td>
<td></td>
<td>Да</td>
<td></td>
</tr>
<tr>
<td>Выводится ошибка</td>
<td></td>
<td></td>
<td></td>
<td>Да</td>
</tr>
</tbody>
</table>
<p>После составления такой таблицы можно без труда составить тест-кейсы. В этом примере мы строили таблицу, начиная от входных условий, однако, часто бывают ситуации, когда сразу ясны результаты, и мы уже отталкиваемся от них, чтобы расписать условия для входа.</p>
<hr />
<p>Давайте двигаться дальше и познакомимся с ещё одной техникой — это модели переходов и состояний.  Эта модель представляет собой набор состояний, в которых может находиться программа, и набор переходов (правил, условий), по которым система может переходить из одного состояния в другое. Такую модель можно визуально представить как диаграмму состояний. Так вот у любой такой модели есть набор состояний, которые может занять программа; переходы от одного состояния в другое; события, которые являются причиной перехода; и действия, которые являются результатом перехода.</p>
<p><img alt="modelperehodov.png" src="../../img/modelperehodov.png" /></p>
<p>Давайте рассмотрим простой пример: ввод ПИН-кода для карты. Кружками обозначены состояния системы, их семь. Возможные переходы нарисованы стрелками, события/причины указаны рядом со стрелками, а возможными результатами будет являться открытый доступ к счету или изъятие карты. Вы можете строить настолько подробные диаграммы состояний, насколько вам необходимо и позволяют временные ресурсы. Системы или компоненты наиболее важные для тестирования могут быть проанализированы глубоко, другие же, наименее важные, могут обойтись парой состояний.</p>
<p>После построения диаграммы можно выбрать подход к составлению тест-кейсов, можно покрывать каждое состояние или каждый переход, или же комбинировать их. Опять же в данной ситуации мы построили валидный набор переходов и состояний системы. Как быть с негативными проверками, откуда их подобрать? Для этого можно воспользоваться таблицей состояний. В строках указываем возможные состояния системы, по столбцам — события, провоцирующие переходы. На пересечении строк и столбцов в ячейку записываем возможное новое состояние системы. При таком анализе состояний появятся ячейки, где неочевидно, в какое состояние перейдёт система, и это то узкое место, где стоит проверить поведение.</p>
<table>
<thead>
<tr>
<th></th>
<th>Вставить карту</th>
<th>Валидный ПИН-код</th>
<th>Невалидный ПИН-код</th>
</tr>
</thead>
<tbody>
<tr>
<td>С1 Начальное состояние</td>
<td>С2</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>С2 Ожидание пин кода</td>
<td>-</td>
<td>С6</td>
<td>С3</td>
</tr>
<tr>
<td>С3 1ая попытка неудачна</td>
<td>-</td>
<td>С6</td>
<td>С4</td>
</tr>
<tr>
<td>С4 2ая попытка неудачна</td>
<td>-</td>
<td>С6</td>
<td>С5</td>
</tr>
<tr>
<td>С5 3я попытка неудачна</td>
<td>-</td>
<td>-</td>
<td>С7</td>
</tr>
<tr>
<td>С6 Пин код принят</td>
<td>-</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>С7 Карта съедена</td>
<td>С1 (для новой карты)</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>Ячейки, обозначенные знаком вопроса, являются тем местом, где непонятно, как поведёт себя система. Например, может быть такой сценарий: ПИН-код принят и есть доступ к счёту, и очередная попытка ввода ПИН-кода будет принята, как запрос суммы на снятие. На такие моменты тестировщик должен обращать внимание и выяснять состояние и поведение системы при стечении таких обстоятельств.</p>
<p>Ну и последняя из техник черного ящика — это пользовательские кейсы (Use cases). Это техника, позволяющая разрабатывать тесты, основываясь на действиях пользователя в системе, проработать кейс от начала до конца. Такие кейсы называются end-to-end. Каждый кейс — это описание пользовательских действий для конкретного случая и поведения системы в ответ на действия пользователя. Пользователем может быть как человек, так и другая система, взаимодействующая с тестируемой. Пользовательский кейс состоит из набора последовательных действий пользователя и ответа системы на эти действия. Кроме того, должно быть описание входных условий для выполнения такого теста и конечного результата.</p>
<p><img alt="useсase.png" src="../../img/use%D1%81ase.png" /></p>
<p>В данной таблице представлен пример пользовательского кейса для ввода ПИН-кода карты. Верхняя часть таблицы — это позитивный основной кейс, внизу же таблицы можно расписать так называемые расширения кейса. </p>
<p>Техника пользовательских кейсов применима на уровне системного  приемочного тестирования.</p>
<h2 id="-_2">Техники тест-дизайна. Белый ящик.</h2>
<p>Белый, или стеклянный, ящик подразумевает проверку содержимого системы, при этом важно понимать, как система работает внутри, иметь доступ к коду.</p>
<p>Техники на основе белого ящика используются для оценки объёма тестирования, выполненного с помощью тестов чёрного ящика или других проведенных тестов. Вторая причина их использования — разработка дополнительных тест-кейсов с целью увеличения тестового покрытия. Поэтому техники белого ящика стоит использовать как дополнение к остальным техникам. </p>
<p>Какие бывают техники? Например, техники покрытия операторов (Statement coverage), когда проводим подсчёт покрытых операторов в коде, например условных операторов.</p>
<pre><code>Дано число Х
Если Х / 2 = 0 То Число Х - четное
Иначе Число Х - Нечетное
</code></pre>
<p><img alt="algorithm.png" src="../../img/algorithm.png" /></p>
<p>Другой тип — техники покрытия решений или веток (Decision coverage). Для нашего примера достаточно одного тест-кейса для достижения стопроцентного покрытия оператора и двух тест-кейсов для покрытия решений.</p>
<p>В среднем техники черного ящика покрывают условия в коде на 60 -75 процентов. Используя белый ящик этот процент можно повысить.</p>
<p>Давайте разберемся с понятием “тестовое покрытие” (Test coverage). Это мера, которая определяет количество покрытых тестами элементов программного продукта. Элементом продукта в данном случае могут быть строки или ветки кода, функции или пункты меню в интерфейсе, права пользователей для использования продукта. Одним словом, всё, что мы можем протестировать.</p>
<p>Как же посчитать процент покрытия тестами элементов продукта? Считаем отношение количества протестированных элементов к общему количеству элементов и умножаем на сто процентов.</p>
<p>Покрытие = (Количество протестированных элементов /
Общее количество элементов ) * 100%</p>
<p>Однако стопроцентное покрытие, подсчитанное таким образом, не даёт уверенности в стопроцентном проведении тестирования. Например, два разных набора тест-кейсов могут дать одинаковое покрытие, но входные условия для одного могут найти ошибку, а для другого — нет.</p>
<p>Покрытие можно считать по-разному. Есть несколько типов покрытия, определённых на каждом уровне тестирования. Например, на компонентном уровне можно посчитать процент покрытых тестами компонентов и функций каждого. На системном или приёмочном можно отталкиваться от бизнес-процессов и считать их процент покрытия. Помогают также посчитать покрытие техники черного ящика, например сколько классов эквивалентности  протестировано или сколько состояний программы из модели состояний и переходов.</p>
<h2 id="_2">Техники на основе опыта.</h2>
<p>В конце этой темы рассмотрим неформальные техники тестирования на основе знаний и опыта. Хотя их, наверное, не назовешь техникой, потому что здесь фундаментом для тестов являются опыт, знания, интуиция и фантазия тестировщика, от этих же факторов зависит и успех обнаружения проблем в ПО. Первый подход к такому тестированию называется <em>угадывание ошибок</em> (Error guessing). Здесь нет определённых правил и систем, в этом случае рекомендуется подумать о ситуациях, с которыми программа может не справиться и столкнётся с проблемами. Например, деление на ноль, не заполненное обязательное поле ввода, загрузка пустого файла и файла такого типа, который редко встречается. Следует записать эти ситуации и оформить в виде тестов. </p>
<p>Второй подход — исследовательское тестирование (Exploratory testing) — практический, где тестировщик по максимуму вовлечён в выполнение тестирования. Производится небольшая запись того, что протестировано, какие проблемы были обнаружены. Вообще, цель исследовательского тестирования — изучить ПО, что оно выполняет и что не работает в нём. После этого складывается понимание того, что нужно тестировать дальше и сколько отвести на это времени. Такой подход хорош, когда на проекте немного документации с требованиями или когда время ограничено.</p>
<p>Конечно же, эти подходы не являются заменой формальным техникам тестирования, они только хорошее дополнение.</p>
<p>Итак, в этой части курса мы познакомились с основными техниками тест-дизайна. И неверно будет задавать вопрос — какая техника лучше? Они все хороши, каждая для своего применения.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
